var method_name = "ContentManager.cmsHTMLPageFindall";

var server_time = new Date(2019, 12-1, 9, 11, 52, 33);

var execution_time = 0.023074;

ret = new Array();
ret[0] = new Object();
ret[0].ToString = "Report Section";
ret[0]._ToString = "Report Section";
ret[0].Active = false;
ret[0].AlwaysGenerate = false;
ret[0].Body = "";
ret[0].Date = new Date(2018, 7-1, 11, 7, 19, 3);
ret[0].Description = "";
ret[0].Footer = "";
ret[0].ImageSource = "";
ret[0].Page = "Hosted/COM/ReportSection";
ret[0].PreScript = "";
ret[0].Public = false;
ret[0].Script = "window.ReportSection = class {\r\n    constructor(year, companyCode, interval) {\r\n        this._year = year;\r\n        this._companyCode = companyCode;\r\n        this._start = moment().year(this._year).startOf(\'year\');\r\n        this._end = moment().year(this._year).endOf(\'year\');\r\n        this._interval = interval || {\r\n            Month: 1\r\n        };\r\n    }\r\n\r\n    _dates() {\r\n        var ret = [];\r\n        var startOfParam = \"\";\r\n        for (var p in this._interval) {\r\n            startOfParam = p.toLowerCase();\r\n        }\r\n        for (var d = moment(this._start); d <= moment(this._end).add(this._interval).startOf(startOfParam); ret.push(moment(d).toDate()), d.add(this._interval));\r\n        return ret;\r\n    }\r\n\r\n    _pivot(total, format) {\r\n        var ret = [];\r\n        var times = sr.groupBy(total, \'PARTITIONID\');\r\n        for (var i = 0; i < times.length; i++) {\r\n            var groups = sr.groupBy(times[i].values, \'name\');\r\n            for (var j = 0; j < groups.length; j++) {\r\n                ret.push({\r\n                    Time: moment(times[i].key).format(format).toString(),\r\n                    Dimension: groups[j].key,\r\n                    Aggregation: groups[j].values[0].V0\r\n                });\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    _asZingOptions(data) {\r\n        var options = {\r\n            \"graphset\": []\r\n        };\r\n\r\n        for (var g = 0; g < data.labels.length; g++) {\r\n            var gset = {\r\n                type: data.type || \"bar\",\r\n                options: {},\r\n            };\r\n\r\n            gset[\"stacked\"] = data.labels.length > 0;\r\n            gset[\"plot\"] = {\r\n                \"value-box\": {\r\n                    \"text\": \"%stack-total\",\r\n                    //\"jsRule\": \"1+1\",\r\n                    \"rules\": [{\r\n                        \"rule\": \"%stack-top == 0\",\r\n                        \"visible\": 0\r\n                    }]\r\n                },\r\n                tooltip: {\r\n                    text: \"%t %v\"\r\n                }\r\n            };\r\n            gset[\"plotarea\"] = {\r\n                \"margin-right\": \"25%\"\r\n            };\r\n            gset[\"legend\"] = {\r\n                \"toggle-action\": \"hide\",\r\n                \"item\": {\r\n                    \"cursor\": \"pointer\"\r\n                },\r\n                \"draggable\": true,\r\n                \"drag-handler\": \"icon\"\r\n            };\r\n            gset[\"title\"] = {\r\n                \"text\": data.title,\r\n                \"font-family\": \"arial\",\r\n                \"x\": \"40px\",\r\n                \"y\": \"5px\",\r\n                \"align\": \"left\",\r\n                \"bold\": false,\r\n                \"font-size\": \"16px\",\r\n                \"font-color\": \"#000000\",\r\n                \"background-color\": \"none\"\r\n            };\r\n            gset[\"subtitle\"] = {\r\n                \"text\": \"<i>\" + \"Between \" + moment(data.startDate).format(\"DD/MM/YYYY\") + \" and \" + moment(data.endDate).format(\"DD/MM/YYYY\") + \"</i>\",\r\n                \"font-family\": \"arial\",\r\n                \"x\": \"40px\",\r\n                \"y\": \"25px\",\r\n                \"align\": \"left\",\r\n                \"bold\": false,\r\n                \"font-size\": \"16px\",\r\n                \"font-color\": \"#7E7E7E\",\r\n                \"background-color\": \"none\"\r\n            };\r\n\r\n            gset.labels = [];\r\n            for (var t = 0; t < gset.labels.length; t++) {\r\n                gset.labels[t] = {\r\n                    \"text\": gset.labels[t],\r\n                    \"hook\": \"node:plot=2;index=\" + t\r\n                };\r\n            }\r\n            gset[\"scaleX\"] = {\r\n                \"values\": [],\r\n            };\r\n            var labels = sr.groupBy(data.data, data.dimensions[0]);\r\n            for (var i = 0; i < labels.length; i++) {\r\n                gset[\"scaleX\"].values.push(moment(labels[i].key).format(data.interval.Format).toString());\r\n            }\r\n\r\n            gset.series = [];\r\n            var gData = sr.groupBy(data.data, data.labels[g]);\r\n            for (var i = 0; i < gData.length; i++) {\r\n                var values = Array(labels.length);\r\n                for (var j = 0; j < gData[i].values.length; j++) {\r\n                    var v = gData[i].values[j];\r\n                    for (var l = 0; l < labels.length; l++) {\r\n                        if (labels[l].key == v[data.dimensions[0]]) {\r\n                            values[l] = parseInt(v[data.values[0]]);\r\n                        } else {\r\n                            values[l] = values[l] || 0;\r\n                        }\r\n                    }\r\n                }\r\n                gset.series.push({\r\n                    values: values,\r\n                    text: gData[i].key,\r\n                });\r\n            }\r\n\r\n            options.graphset.push(gset);\r\n        }\r\n        //console.log(options);\r\n        return options;\r\n    }\r\n\r\n    _topData(ar, gField, vField, top) {\r\n        $.each(ar, (_, v) => {\r\n            v[vField] = v[vField] || 0;\r\n        });\r\n\r\n        if (!top) {\r\n            return ar;\r\n        }\r\n\r\n        var ret = [];\r\n        $.each(sr.groupBy(ar, gField), (_, key) => {\r\n            key.values = key.values.sort((a, b) => {\r\n                if (parseFloat(a[vField]) < parseFloat(b[vField])) {\r\n                    return 1;\r\n                } else if (parseFloat(a[vField]) > parseFloat(b[vField])) {\r\n                    return -1;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            });\r\n            ret = ret.concat(key.values.slice(0, top));\r\n        });\r\n        return ret;\r\n    }\r\n\r\n    _On(p, type, start, end) {\r\n        p.OPERATORS = p.OPERATORS || {};\r\n        if (start && !end) {\r\n            p[type + \'On\'] = \'${rMax}\' || moment(start).toDate();\r\n            p.OPERATORS[type + \'On\'] = \"<=\";\r\n        } else if (!start && end) {\r\n            p[type + \'On\'] = \'${rMin}\' || moment(end).toDate();\r\n            p.OPERATORS[type + \'On\'] = \">=\";\r\n        } else if (start && end) {\r\n            p[type + \'On\'] = \"${rMin}\"; //moment(start).toDate();\r\n            p.OPERATORS[type + \'On\'] = \"BETWEEN ${rMax}\"; // + (sr.toDateTime(moment(end).toDate()) || end);\r\n        }\r\n    }\r\n\r\n    _takenOn(p) {\r\n        return this._On(p, \'Taken\', this._start, this._end);\r\n    }\r\n\r\n    _startedOn(p) {\r\n        return this._On(p, \'Started\', this._start);\r\n    }\r\n\r\n    _endedOn(p) {\r\n        return this._On(p, \'Ended\', null, this._end);\r\n    }\r\n\r\n    _data(total, type, title) {\r\n        return {\r\n            type: type || \'bar\',\r\n            data: this._topData(total, \"PARTITIONID\", \"V0\", 5),\r\n            labels: [\"name\"],\r\n            values: [\'V0\'],\r\n            dimensions: [\'PARTITIONID\'],\r\n            title: /*\"Top \" + top + \" \" + */ title || \"\",\r\n            startDate: total[0].PARTITIONID, //this._start,\r\n            endDate: total[total.length - 1].PARTITIONID, //this._end,\r\n            interval: {\r\n                Month: 1,\r\n                Format: \'MMM/YY\'\r\n            },\r\n        };\r\n    }\r\n\r\n    _piv(f, keyFields, filters, _OnType) {\r\n        _OnType = _OnType || [\'taken\'];\r\n        if (!Array.isArray(_OnType)) {\r\n            _OnType = [_OnType];\r\n        }\r\n        var dm = f.DataMap || f;\r\n        var p = {\r\n            Active: true,\r\n            Batch: {\r\n                Active: true,\r\n                Enabled: true,\r\n            },\r\n            DataSet: {\r\n                Active: true,\r\n                DataMap: dm,\r\n            },\r\n            PerformanceIdentities: [],\r\n            OPERATORS: {\r\n                PerformanceIdentities: \"INTERSECT\"\r\n            },\r\n        };\r\n        var pi = {\r\n            Last900: -900,\r\n            Active: true,\r\n            Performance: p,\r\n        };\r\n\r\n        $.map(_OnType, o => this[\'_\' + o + \'On\'](pi.Performance));\r\n\r\n        $.each(keyFields, (__, _kf) => {\r\n            var _pi = {\r\n                Active: true,\r\n                DataField: _kf,\r\n                Identity: {\r\n                    Active: true,\r\n                    Group: _kf.Group,\r\n                    Id: pi.Last900--,\r\n                },\r\n            };\r\n            pi.Performance.PerformanceIdentities.push(_pi);\r\n        });\r\n\r\n        $.each(filters, (__, _fs) => {\r\n            pi.Performance.PerformanceIdentities.push({\r\n                Active: true,\r\n                Identity: _fs,\r\n            });\r\n        });\r\n        if (f.DataMap) {\r\n            if (!f.CodeField) {\r\n                // pi is a performance value\r\n                pi.DataMapValue = f;\r\n            } else {\r\n                // pi is a performance identity\r\n                pi.Identity = {\r\n                    Active: true,\r\n                    Group: f.Group,\r\n                };\r\n                pi.DataField = f;\r\n            }\r\n        } else if (_OnType.indexOf(\'started\') > -1 && _OnType.indexOf(\'ended\') > -1) {\r\n            return {\r\n                Active: true,\r\n                Group: {\r\n                    Active: true,\r\n                    DataFields: [{\r\n                        Active: true,\r\n                        Enabled: true,\r\n                        Primary: true,\r\n                        DataMap: dm\r\n                    }],\r\n                },\r\n                PerformanceIdentities: [{\r\n                    DataField: {\r\n                        Primary: true,\r\n                        Active: true,\r\n                        Enabled: true,\r\n                        DataMap: dm\r\n                    },\r\n                    Active: true,\r\n                    Performance: pi.Performance\r\n                }]\r\n            };\r\n        } else {\r\n            return pi.Performance;\r\n        }\r\n\r\n        return pi;\r\n    }\r\n\r\n    _propApply(object, fApply) {\r\n        for (var property in object) {\r\n            if (!object.hasOwnProperty(property)) continue;\r\n            if (fApply) fApply(object, property, object[property]);\r\n            if (typeof object[property] == \"object\") {\r\n                if (object[property].constructor.toString().indexOf(\"Array()\") > -1 && object[property].length) {\r\n                    // array\r\n                    for (var i = 0; i < object[property].length; i++) {\r\n                        this._propApply(object[property][i], fApply);\r\n                    }\r\n                } else {\r\n                    // an object\r\n                    this._propApply(object[property], fApply);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    _prepareLink(name, _OnType) {\r\n        return $.when(\r\n            sr._(\'CorporateMeasures.comGroupViewLinkFindall\', null, {\r\n                Name: name\r\n            })\r\n        ).then(gvl => {\r\n            var calls = [];\r\n            $.merge(calls, $.map(gvl, l => this._prepare(l.BaseGroupView.Name, _OnType)));\r\n            $.merge(calls, $.map(gvl, l => this._prepare(l.SubGroupView.Name, _OnType)));\r\n\r\n            return $.when(...calls).then((...kvs) => {\r\n                var ret = {\r\n                    Keys: kvs[0].Keys,\r\n                    Values: []\r\n                };\r\n                $.each(kvs[1].Values, (_, v) => {\r\n                    this._propApply(v, (o, p, pv) => {\r\n                        if (p === \"Identity\" && pv.Id <= -900 && pv.Group && pv.Group.Id == gvl[0].SubDataField.Groupid) {\r\n                            // link with base data field\r\n                            delete o.Identity.Id;\r\n                            o.Identity.PerformanceIdentities = [{\r\n                                Active: true,\r\n                                DataField: gvl[0].BaseDataField,\r\n                            }];\r\n                            if (kvs[0].Values[0].Batch) {\r\n                                // a performance\r\n                                o.Identity.PerformanceIdentities[0].Performance = kvs[0].Values[0];\r\n                            } else {\r\n                                var pr = {\r\n                                    Active: true,\r\n                                    DataSet: {\r\n                                        Active: true,\r\n                                        Enabled: true,\r\n                                        DataMap: {\r\n                                            Active: true,\r\n                                            Id: gvl[0].BaseDataField.DataMapid\r\n                                        },\r\n                                    },\r\n                                };\r\n                                if (kvs[0].Values[0].DataField) {\r\n                                    pr.PerformanceIdentities = [kvs[0].Values[0]];\r\n                                } else if (kvs[0].Values[0].DataMapValue) {\r\n                                    pr.PerformanceValues = [kvs[0].Values[0]];\r\n                                }\r\n                                o.Identity.PerformanceIdentities[0].Performance = pr;\r\n                            }\r\n                        }\r\n                    });\r\n                    ret.Values.push(v);\r\n                });\r\n\r\n                console.log(\"L: \" + name);\r\n                console.log(ret);\r\n                return ret;\r\n            });\r\n        });\r\n    }\r\n\r\n    async _prepare(name, _OnType) {\r\n        var _gv = {\r\n            Name: name,\r\n            OPERATORS: {\r\n                Name: \'=\'\r\n            }\r\n        };\r\n        let kf = await sr._(\'CorporateMeasures.comDataFieldFindall\', null, {\r\n            KeyGroupViews: [_gv]\r\n        });\r\n        let vf = await sr._(\'CorporateMeasures.comDataFieldFindall\', null, {\r\n            ValueGroupViews: [_gv]\r\n        });\r\n        let dmv = await sr._(\'CorporateMeasures.comDataMapValueFindall\', null, {\r\n            GroupViews: [_gv]\r\n        });\r\n        let fs = await sr._(\'CorporateMeasures.comIdentityFindall\', null, {\r\n            GroupViews: [_gv]\r\n        });\r\n        let gv = await sr._(\'CorporateMeasures.comGroupViewFind\', null, _gv);\r\n        _OnType = gv.PartitionField ? gv.PartitionField.split(\',\') : _OnType;\r\n        var vfs = [];\r\n\r\n        $.merge(vfs, $.map(vf, f => {\r\n            return this._piv(f, kf, fs, _OnType);\r\n        }));\r\n        $.merge(vfs, $.map(dmv, f => {\r\n            return this._piv(f, kf, fs, _OnType);\r\n        }));\r\n\r\n        if (!vfs.length) {\r\n            // count performances, send datamap instead of field\r\n            if (kf.length) {\r\n                vfs = [this._piv(kf[0].DataMap, kf, fs, _OnType)];\r\n            } else {\r\n                vfs = [this._piv(gv.DataMap, kf, fs, _OnType)];\r\n            }\r\n        }\r\n\r\n        var ret = {\r\n            Keys: kf,\r\n            Values: vfs,\r\n        };\r\n\r\n        console.log(ret);\r\n        console.log(name);\r\n\r\n        return ret;\r\n    }\r\n\r\n    async _runAggregation(gv, aggs, kv, pts, _OnType) {\r\n        if (gv === null) return;\r\n        _OnType = gv.PartitionField ? gv.PartitionField.split(\',\') : _OnType;\r\n        window.sr.bAsync = gv.Async;\r\n\r\n        var partitions = this._dates();\r\n        if (pts && pts.length) {\r\n            partitions = $.map(pts, p => p.Value);\r\n            partitions.push(1000 * pts[pts.length - 1].Value);\r\n        }\r\n\r\n        var id_values = [];\r\n        var pi_values = [];\r\n        var pv_values = [];\r\n        var p_values = [];\r\n        $.each(kv.Values, (_, kvv) => {\r\n            if (kvv.DataMapValue) pv_values.push(kvv);\r\n            if (kvv.DataField) pi_values.push(kvv);\r\n            if (kvv.Batch) p_values.push(kvv);\r\n            if (kvv.Group) id_values.push(kvv);\r\n        });\r\n        if (pts && pts.length) {\r\n            $.each(pv_values, (_, piv) => {\r\n                if (!piv.Value) {\r\n                    piv.Value = 1;\r\n                    piv.OPERATORS = piv.OPERATORS || {};\r\n                    piv.OPERATORS.Value = \"BETWEEN 1\";\r\n                }\r\n            });\r\n        }\r\n        for (var i = aggs.length; i < (pv_values.length + pi_values.length + p_values.length + id_values.length); i++) {\r\n            aggs.push({\r\n                Code: \'COUNT\'\r\n            });\r\n        }\r\n        let ret = await sr._(\'CorporateMeasures.comGroupViewAggregation\', null, $.map(kv.Keys, k => {\r\n            return {\r\n                Active: true,\r\n                Group: k.Group\r\n            };\r\n        }), id_values, pi_values, pv_values, p_values, partitions, $.map(_OnType, o => o + \'On\'), $.map(aggs, ag => ag.Code), gv.FieldFormatter, window.bTest || false);\r\n        return ret;\r\n    }\r\n\r\n    async _run(name, _OnType) {\r\n        var _gv = {\r\n            Name: name,\r\n            OPERATORS: {\r\n                Name: \'=\'\r\n            }\r\n        };\r\n        let gv = await sr._(\'CorporateMeasures.comGroupViewFind\', null, _gv);\r\n        let aggs = await sr._(\'CorporateMeasures.comAggregationFindall\', null, {\r\n            GroupViews: [_gv]\r\n        });\r\n        let kv = await this._prepare(name, _OnType);\r\n        let ptx = await sr._(\'CorporateMeasures.comViewPartitionFindall\', null, {\r\n            GroupView: _gv\r\n        });\r\n        let ret = await this._runAggregation(gv, aggs, kv, ptx, _OnType);\r\n        return ret;\r\n    }\r\n\r\n    _runLink(name, _OnType) {\r\n        var _gv = {\r\n            Enabled: true,\r\n            SubGroupViewLinks: [{\r\n                Name: name,\r\n                Enabled: true,\r\n                OPERATORS: {\r\n                    Name: \'=\'\r\n                }\r\n            }]\r\n        };\r\n        return $.when(\r\n            sr._(\'CorporateMeasures.comGroupViewFind\', null, _gv),\r\n            sr._(\'CorporateMeasures.comAggregationFindall\', null, {\r\n                GroupViews: [_gv]\r\n            }),\r\n            this._prepareLink(name, _OnType),\r\n            sr._(\'CorporateMeasures.comViewPartitionFindall\', null, {\r\n                GroupView: _gv\r\n            })\r\n        ).then((gv, aggs, kv, pts) => {\r\n            return this._runAggregation(gv, aggs, kv, pts, _OnType);\r\n        });\r\n    }\r\n};";
ret[0].Title = "Report Section";
ret[0].Id = 1595;
ret[0].Authorid = 0;
ret[0].SectionPages = new Array();
ret[0].PageMenus = new Array();
ret[0].RelatingPages = new Array();
ret[0].RelatedPages = new Array();
ret[0].PageAccessRules = new Array();
ret[0].BugReports = new Array();
ret[0].PageAccessRights = new Array();
ret[0].PageStatuses = new Array();
ret[0].ReferenceMenus = new Array();
ret[0].PageAccessRequests = new Array();
ret[0].FeedbackPages = new Array();
ret[0].PageHelps = new Array();